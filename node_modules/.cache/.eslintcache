[{"/Users/jessicaliu/costgo/src/index.js":"1","/Users/jessicaliu/costgo/src/reportWebVitals.js":"2","/Users/jessicaliu/costgo/src/App.js":"3","/Users/jessicaliu/costgo/src/components/Header.jsx":"4","/Users/jessicaliu/costgo/src/components/sample.jsx":"5","/Users/jessicaliu/costgo/src/components/Content.jsx":"6","/Users/jessicaliu/costgo/src/components/Path.jsx":"7","/Users/jessicaliu/costgo/src/components/shortestPathFinder.js":"8","/Users/jessicaliu/costgo/src/components/Button.jsx":"9","/Users/jessicaliu/costgo/src/components/Inventory.jsx":"10","/Users/jessicaliu/costgo/src/test.js":"11","/Users/jessicaliu/costgo/src/components/Images.jsx":"12","/Users/jessicaliu/costgo/src/components/Item.jsx":"13","/Users/jessicaliu/costgo/src/components/Checkbox.jsx":"14","/Users/jessicaliu/costgo/src/components/Emoji.jsx":"15"},{"size":500,"mtime":1625677271753,"results":"16","hashOfConfig":"17"},{"size":362,"mtime":1625671873779,"results":"18","hashOfConfig":"17"},{"size":606,"mtime":1625671873425,"results":"19","hashOfConfig":"17"},{"size":642,"mtime":1625671873775,"results":"20","hashOfConfig":"17"},{"size":2352,"mtime":1625671873777,"results":"21","hashOfConfig":"17"},{"size":2243,"mtime":1625678965519,"results":"22","hashOfConfig":"17"},{"size":2100,"mtime":1625678370038,"results":"23","hashOfConfig":"17"},{"size":8312,"mtime":1625671873777,"results":"24","hashOfConfig":"17"},{"size":943,"mtime":1625678806081,"results":"25","hashOfConfig":"17"},{"size":1802,"mtime":1625676947032,"results":"26","hashOfConfig":"17"},{"size":1480,"mtime":1625671873780,"results":"27","hashOfConfig":"17"},{"size":2611,"mtime":1625671873776,"results":"28","hashOfConfig":"17"},{"size":1785,"mtime":1625674276566,"results":"29","hashOfConfig":"17"},{"size":1446,"mtime":1625671873774,"results":"30","hashOfConfig":"17"},{"size":277,"mtime":1625673979155,"results":"31","hashOfConfig":"17"},{"filePath":"32","messages":"33","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},"1fbxz9v",{"filePath":"34","messages":"35","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"36"},{"filePath":"37","messages":"38","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"36"},{"filePath":"39","messages":"40","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"36"},{"filePath":"41","messages":"42","errorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"43","usedDeprecatedRules":"36"},{"filePath":"44","messages":"45","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"46","messages":"47","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"48","messages":"49","errorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"50","usedDeprecatedRules":"36"},{"filePath":"51","messages":"52","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"53","messages":"54","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"55","messages":"56","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"36"},{"filePath":"57","messages":"58","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"36"},{"filePath":"59","messages":"60","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"36"},{"filePath":"61","messages":"62","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"36"},{"filePath":"63","messages":"64","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"36"},"/Users/jessicaliu/costgo/src/index.js",[],"/Users/jessicaliu/costgo/src/reportWebVitals.js",[],["65","66"],"/Users/jessicaliu/costgo/src/App.js",[],"/Users/jessicaliu/costgo/src/components/Header.jsx",[],"/Users/jessicaliu/costgo/src/components/sample.jsx",["67","68","69"],"import React, { Component } from 'react';\nimport ShortestPathFinder from \"./shortestPathFinder.js\";\n\nimport map from '../data/map.json'\nimport tests from '../test.js' \n\nimport styled from 'styled-components';\n\n\nconst Container = styled.div`\n  background-color: #364C83;\n  border-radius: 20px;\n  margin-left: 7%;\n  margin-right: 7%;\n  height: 60vh;\n  display: flexbox;\n  justify-content: center; \n  align-items: center;\n  \n`;\n\n\nconsole.log(map[\"Chips\"]);\n\nclass Graph extends Component {\n\ncomponentDidMount(){\n    var c = document.getElementById(\"canvas\");\n    var ctx = c.getContext(\"2d\");\n\n\n    var total_aisle = 12;\n\n    var position = 0;\n    function drawAisle(aisleWidth, shelfWidth, shelfLength ){\n        ctx.fillStyle = 'brown';\n        for(let i = 0; i < total_aisle; i++){\n            ctx.beginPath();\n            ctx.fillRect(position, 30, shelfWidth, shelfLength);\n            position += shelfWidth+ aisleWidth;\n        }\n        \n    }\n\n    drawAisle(80,30,180);\n\n\n    var visited_array = {};\n    ctx.fillStyle = 'white';\n    for (var key in map) {\n        \n        if (map.hasOwnProperty(key)) {\n\n            visited_array[key] = false;\n\n            let id_str = key;\n            let x = map[key].x;\n            let y = map[key].y;\n            ctx.font = \"8px Arial\";\n            ctx.fillText(id_str.substring(0, 5), x, y);\n        }\n    }\n\n\n    function draw_path(array){\n\n        for(let i = 0; i < array.length; i++){\n            \n            if((i+1)!= array.length){\n                let curr_node = map[array[i]];\n                let next_node = map[array[i+1]]; \n    \n                ctx.strokeStyle = '#88F37F';\n                ctx.lineWidth = 3;\n                \n                // draw a red line\n\n                ctx.font = \"15px Arial\";\n                ctx.fillText(i+1, curr_node.x, curr_node.y);\n\n                ctx.beginPath();\n                ctx.moveTo(curr_node.x, curr_node.y);\n                ctx.lineTo(next_node.x, next_node.y);\n                ctx.stroke();\n    \n            }\n    \n    \n        }\n    } \n\n    //document.getElementById(\"items\").innerHTML= this.props.path;\n    draw_path(this.props.path);    \n\n\n}\n  render() {\n    return (\n        <Container>\n            <canvas  id=\"canvas\" width=\"1600\" height=\"400\"></canvas>\n        </Container>\n    );\n  }\n}\n\n\nconsole.log(\"Heloooo!!!!\");\n\n\n\nexport default Graph;","/Users/jessicaliu/costgo/src/components/Content.jsx",["70"],"/Users/jessicaliu/costgo/src/components/Path.jsx",[],"/Users/jessicaliu/costgo/src/components/shortestPathFinder.js",["71","72","73","74"],"import map from '../data/map.json';\n\nclass QElement{\n    constructor(element,priority){\n        this.element=element;\n        this.priority=priority;\n    }\n}\n\nclass PriorityQueue{\n    constructor(){\n        this.heap=[null];\n    }\n    isEmpty(){\n        return this.heap.length == 1;\n    }\n    enqueue(node,priority){\n  // creating object from queue element\n        var qElement = new QElement(node, priority);\n        this.heap.push(qElement);\n    \n    /* Finding the correct position for the new node */\n\n        if (this.heap.length > 1) {\n            let current = this.heap.length - 1\n        \n        /* Traversing up the parent node until the current node (current) is greater than the parent (current/2)*/\n            while (current > 1 && this.heap[Math.floor(current/2)].priority > this.heap[current].priority) {\n        \n            /* Swapping the two nodes by using the ES6 destructuring syntax*/\n                [this.heap[Math.floor(current/2)], this.heap[current]] = [this.heap[current], this.heap[Math.floor(current/2)]]\n                current = Math.floor(current/2)\n            }\n        }\n    }\n\n    dequeue(){\n        let smallest = this.heap[1]\n    \n        /* When there are more than two elements in the array, we put the right most element at the first position\n            and start comparing nodes with the child nodes\n        */\n        if (this.heap.length > 2) {\n            this.heap[1] = this.heap[this.heap.length-1]\n            this.heap.splice(this.heap.length - 1)\n    \n            if (this.heap.length === 3) {\n                if (this.heap[1].priority > this.heap[2].priority) {\n                    [this.heap[1], this.heap[2]] = [this.heap[2], this.heap[1]]\n                }\n                return smallest.element;\n            }\n    \n            let current = 1\n            let leftChildIndex = current * 2\n            let rightChildIndex = current * 2 + 1\n    \n            while (this.heap[leftChildIndex] &&\n                    this.heap[rightChildIndex] &&\n                    (this.heap[current].priority > this.heap[leftChildIndex].priority ||\n                        this.heap[current].priority > this.heap[rightChildIndex].priority)) {\n                if (this.heap[leftChildIndex].priority < this.heap[rightChildIndex].priority) {\n                    [this.heap[current], this.heap[leftChildIndex]] = [this.heap[leftChildIndex], this.heap[current]]\n                    current = leftChildIndex\n                } else {\n                    [this.heap[current], this.heap[rightChildIndex]] = [this.heap[rightChildIndex], this.heap[current]]\n                    current = rightChildIndex\n                }\n    \n                leftChildIndex = current * 2\n                rightChildIndex = current * 2 + 1\n            }\n        }\n        \n        /* If there are only two elements in the array, we directly splice out the first element */\n        \n        else if (this.heap.length === 2) {\n            this.heap.splice(1, 1)\n        } else {\n            return null\n        }\n    \n        return smallest.element;\n  \n    }\n}\n\nclass ShortestPathFinder{\n    constructor(){\n        this.map=map;\n    }\n\n    //@param items\n    //array of strings of names of items of shopping cart\n    getShortestPath(items){\n        //Start path on start node\n        let curItem = this.map.start; //curItem is a node\n        let path = [\"start\"]; //array of strings of names of items\n\n        while(items.length > 0) {\n            let dists = this.dijkstras(curItem);\n            let nextItem = this.searchForShortestItem(dists,items);\n            let pathToNextItem = [nextItem];\n            let curPathNode = nextItem;\n            while(dists[curPathNode].parent !== curItem.name) {\n                curPathNode = dists[curPathNode].parent;\n                pathToNextItem.unshift(curPathNode);       \n            }   \n\n            Array.prototype.push.apply(path, pathToNextItem)\n\n            curItem = this.map[nextItem];\n\n            //remove current item from items\n            const index = items.indexOf(curItem.name);\n            if (index > -1) {\n                items.splice(index, 1);\n            }\n        }\n        path.push(\"bottomAisle\"+this.map[path[path.length - 1]].aisle);\n        path.push(\"exit\")\n        return path;\n    }\n    dijkstras(node){\n        let dists={};\n        dists[node.name]={dist:0,parent:null};\n        let pq= new PriorityQueue();\n        pq.enqueue(node.name,0);\n        while (!pq.isEmpty()){\n            let dq=pq.dequeue();\n            let curr=this.map[dq];\n            for(const n of Object.keys(curr.neighbors)){\n                if(dists[n] === undefined || dists[n].dist > dists[curr.name].dist + curr.neighbors[n])\n                {\n                    dists[n] = {dist: dists[curr.name].dist + curr.neighbors[n],parent:curr.name};\n                    pq.enqueue(n,dists[n].dist);\n                }\n            }\n        }\n        return dists;\n        //in a loop, continually visit the closest unvisited node to root, relaxing all its neighbors.\n\n\n    }\n    searchForShortestItem(dists,items){\n        var item; \n        var minDistance = Number.MAX_VALUE; \n\n        for(let i = 0; i < items.length; i++){\n            if(dists[items[i]].dist < minDistance){\n                item = items[i]; \n                minDistance = dists[items[i]].dist;\n            }\n        }\n        \n        return item;\n    }\n}\n\nfunction equals(list1,list2){\n    if(list1.length != list2.length){\n        return false;\n    }\n    for(let i=0;i<list1.length;i++){\n        if(list1[i] != list2[i]){\n            return false;\n        }\n    }\n    return true;\n}\nfunction testShortestPathFinder(){\n    let tests = [\n        {items:[\"Juices\",\"Bread\"],shortestPath:[\n            'start',\n            'topAisle9',\n            'Bread',\n            'bottomAisle9',\n            'bottomAisle10',\n            'Juices',\n            'bottomAisle10',\n            'exit'\n          ]},\n        {items:[\"Chips\",\"Nuts\",\"Candy\",\"CannedFish\"],shortestPath:[\n        'start','topAisle4',\n        'Candy',        'bottomAisle4',\n        'bottomAisle5', 'Chips',\n        'Nuts',         'topAisle5',\n        'topAisle6',    'topAisle7',\n        'CannedFish',   'bottomAisle7',\n        'exit']},\n        {items:[\"ProteinPowder\",\"Tea\",\"Coffee\",\"Oats\",\"DriedFruit\"],shortestPath:[  \n        'start',         'topAisle3',\n        'ProteinPowder', 'bottomAisle3',\n        'bottomAisle4',  'bottomAisle5',\n        'bottomAisle6',  'DriedFruit',\n        'topAisle6',     'topAisle7',\n        'topAisle8',     'topAisle9',\n        'topAisle10',    'Oats',\n        'topAisle10',    'topAisle11',\n        'Tea',           'Coffee',\n        'bottomAisle11', 'exit']},\n        {items:[\"Olives\",\"Beans\",\"Oil\",\"Rice\",\"Tea\",\"NutBars\"],shortestPath:[\n            'start',         'topAisle3',\n            'NutBars',       'bottomAisle3',\n            'bottomAisle4',  'bottomAisle5',\n            'bottomAisle6',  'Rice',\n            'bottomAisle6',  'bottomAisle7',\n            'Olives',        'Beans',\n            'topAisle7',     'topAisle8',\n            'Oil',           'topAisle8',\n            'topAisle9',     'topAisle10',\n            'topAisle11',    'Tea',\n            'bottomAisle11', 'exit']},\n        {items:[\"BabyProducts\",\"ChildSupplements\",\"Condiments\",\"Coffee\",\"Sugar\",\"PeanutButter\",\"Cereal\"],shortestPath:[\n            'start',         'topAisle2',\n            'BabyProducts',  'ChildSupplements',\n            'bottomAisle2',  'bottomAisle3',\n            'bottomAisle4',  'bottomAisle5',\n            'bottomAisle6',  'bottomAisle7',\n            'Condiments',    'bottomAisle7',\n            'bottomAisle8',  'Sugar',\n            'bottomAisle8',  'bottomAisle9',\n            'Cereal',        'bottomAisle9',\n            'bottomAisle10', 'PeanutButter',\n            'bottomAisle10', 'bottomAisle11',\n            'Coffee',        'bottomAisle11',\n            'exit']}\n    ]\n    let spf = new ShortestPathFinder();\n    for (const test of tests){\n        let path=spf.getShortestPath(test.items);\n        console.log(\"found the path:\",path);\n        if(!equals(path,test.shortestPath)){\n            console.log(\"failed this test!:\",test);\n        } \n        else{\n            console.log(\"test passed\");\n        }\n    }\n}\n//testShortestPathFinder();\nexport default ShortestPathFinder;","/Users/jessicaliu/costgo/src/components/Button.jsx",[],"/Users/jessicaliu/costgo/src/components/Inventory.jsx",["75","76"],"/Users/jessicaliu/costgo/src/test.js",[],"/Users/jessicaliu/costgo/src/components/Images.jsx",[],"/Users/jessicaliu/costgo/src/components/Item.jsx",[],"/Users/jessicaliu/costgo/src/components/Checkbox.jsx",[],"/Users/jessicaliu/costgo/src/components/Emoji.jsx",[],{"ruleId":"77","replacedBy":"78"},{"ruleId":"79","replacedBy":"80"},{"ruleId":"81","severity":1,"message":"82","line":2,"column":8,"nodeType":"83","messageId":"84","endLine":2,"endColumn":26},{"ruleId":"81","severity":1,"message":"85","line":5,"column":8,"nodeType":"83","messageId":"84","endLine":5,"endColumn":13},{"ruleId":"86","severity":1,"message":"87","line":69,"column":21,"nodeType":"88","messageId":"89","endLine":69,"endColumn":23},{"ruleId":"90","severity":1,"message":"91","line":76,"column":5,"nodeType":"92","messageId":"93","endLine":76,"endColumn":28},{"ruleId":"86","severity":1,"message":"94","line":15,"column":33,"nodeType":"88","messageId":"89","endLine":15,"endColumn":35},{"ruleId":"86","severity":1,"message":"87","line":161,"column":21,"nodeType":"88","messageId":"89","endLine":161,"endColumn":23},{"ruleId":"86","severity":1,"message":"87","line":165,"column":21,"nodeType":"88","messageId":"89","endLine":165,"endColumn":23},{"ruleId":"81","severity":1,"message":"95","line":171,"column":10,"nodeType":"83","messageId":"84","endLine":171,"endColumn":32},{"ruleId":"96","severity":1,"message":"97","line":48,"column":18,"nodeType":"98","messageId":"99","endLine":48,"endColumn":20},{"ruleId":"86","severity":1,"message":"94","line":49,"column":25,"nodeType":"88","messageId":"89","endLine":49,"endColumn":27},"no-native-reassign",["100"],"no-negated-in-lhs",["101"],"no-unused-vars","'ShortestPathFinder' is defined but never used.","Identifier","unusedVar","'tests' is defined but never used.","eqeqeq","Expected '!==' and instead saw '!='.","BinaryExpression","unexpected","react/no-direct-mutation-state","Do not mutate state directly. Use setState().","MemberExpression","noDirectMutation","Expected '===' and instead saw '=='.","'testShortestPathFinder' is defined but never used.","array-callback-return","Array.prototype.map() expects a return value from arrow function.","ArrowFunctionExpression","expectedInside","no-global-assign","no-unsafe-negation"]